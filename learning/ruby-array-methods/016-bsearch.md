# Array#bsearch

- 日付: 2026-01-16
- URL: https://docs.ruby-lang.org/en/4.0/Array.html#method-i-bsearch

## 基本情報

```ruby
bsearch {|element| ... } → found_element or nil
bsearch → new_enumerator
```

**二分探索（binary search）**でブロックの条件を満たす要素を見つけて返します。条件を満たす要素がない場合は `nil` を返します。

## daily からの記録

### メモ

```ruby
# Returns the element from self found by a binary search, or nil if the search found no suitable element.
# 二分探索で見つかった要素、または適切な要素が見つからなかった場合はnilを返します。
ary = [0, 4, 7, 10, 12]
ary.bsearch {|x| x >=   4 } # => 4
ary.bsearch {|x| x >=   6 } # => 7
ary.bsearch {|x| x >=  -1 } # => 0
ary.bsearch {|x| x >= 100 } # => nil

# See Binary Searching.

# Related: see Methods for Fetching.
```

## 深掘り・補足

### 二分探索とは

**二分探索**は、ソート済みの配列から効率的に要素を見つけるアルゴリズムです。配列を半分ずつ絞り込んでいくため、**O(log n)** の時間計算量で非常に高速です。

通常の線形探索（`find`）が O(n) なのに対し、要素数が多い場合に大きな差が出ます：
- 1,000 要素: 線形探索 1,000 回 vs 二分探索 10 回
- 1,000,000 要素: 線形探索 1,000,000 回 vs 二分探索 20 回

### 重要な前提条件

**配列は必ずソート済みである必要があります。** そうでない場合、結果が不正確になります。

```ruby
# ソート済み（正しい）
[1, 3, 5, 7, 9].bsearch { |x| x >= 5 }  # => 5

# ソートされていない（不正確な結果になる可能性）
[3, 1, 9, 5, 7].bsearch { |x| x >= 5 }  # => 予測不可能
```

### 2 つの動作モード

#### 1. Find-minimum モード（最小値探索）

ブロックが **true/false** を返す場合、**条件を満たす最初の要素**を返します。

```ruby
ary = [0, 4, 7, 10, 12]

# 「4 以上」の最初の要素を探す
ary.bsearch { |x| x >= 4 }  # => 4

# 「6 以上」の最初の要素を探す
ary.bsearch { |x| x >= 6 }  # => 7

# すべて条件を満たす場合
ary.bsearch { |x| x >= -1 }  # => 0（最初の要素）

# すべて条件を満たさない場合
ary.bsearch { |x| x >= 100 }  # => nil
```

このモードは「〜以上」「〜より大きい」などの境界値を探すのに便利です。

#### 2. Find-any モード（任意値探索）

ブロックが **-1, 0, 1** を返す場合、**一致する要素**を返します（`<=>` 演算子を使うパターン）。

```ruby
ary = [0, 4, 7, 10, 12]

# 7 と等しい要素を探す
ary.bsearch { |x| x <=> 7 }  # => 7

# 10 と等しい要素を探す
ary.bsearch { |x| 10 <=> x }  # => 10

# 存在しない値を探す
ary.bsearch { |x| x <=> 5 }  # => nil
```

このモードは「特定の値と一致する要素」を探すのに便利です。

### ブロックなしの場合

ブロックを渡さない場合は **Enumerator** を返します。

```ruby
enum = [1, 3, 5, 7, 9].bsearch
# => #<Enumerator: ...>

enum.each { |x| x >= 5 }  # => 5
```

### 実践的なユースケース

#### ユースケース 1: 閾値を超える最初の要素を探す

```ruby
# 売上データから 10万円以上の最初の月を探す
sales = [50000, 75000, 95000, 120000, 150000]
sales.bsearch { |amount| amount >= 100000 }  # => 120000
```

#### ユースケース 2: 特定の値を高速に検索

```ruby
# 大量のユーザー ID から特定の ID を探す（ソート済み前提）
user_ids = [101, 205, 312, 450, 678, 801, 923]
user_ids.bsearch { |id| id <=> 450 }  # => 450
```

#### ユースケース 3: 日時データから特定の期間を探す

```ruby
# タイムスタンプから特定の日以降を探す
timestamps = [1640000000, 1641000000, 1642000000, 1643000000]
target = 1641500000
timestamps.bsearch { |ts| ts >= target }  # => 1642000000
```

### 注意点

1. **配列はソート済みでなければならない**
   - ソートされていない配列では正しく動作しません
   - 必要に応じて事前に `sort` や `sort_by` を使用

2. **nil が返る場合**
   - 条件を満たす要素がない場合
   - `nil` チェックを忘れずに

3. **パフォーマンス**
   - O(log n) で非常に高速
   - ただし、小さな配列（10 要素未満）では `find` でも十分
   - ソートのコスト（O(n log n)）を考慮すること

4. **ブロックの戻り値に注意**
   - true/false か -1/0/1 かで動作が変わる
   - 混在させないこと

### 関連メソッド

- **`bsearch_index`**: 見つかった要素の**インデックス**を返す
  ```ruby
  [0, 4, 7, 10, 12].bsearch_index { |x| x >= 6 }  # => 2
  ```

- **`find` / `detect`**: 線形探索（ソート不要、O(n)）
  ```ruby
  [3, 1, 9, 5, 7].find { |x| x >= 5 }  # => 9（最初に見つかった要素）
  ```

- **`index`**: 特定の値のインデックスを探す（線形探索）
  ```ruby
  [0, 4, 7, 10, 12].index(7)  # => 2
  ```

- **`sort`**: 配列をソートする
  ```ruby
  [3, 1, 9, 5, 7].sort.bsearch { |x| x >= 5 }  # => 5
  ```

### まとめ

`bsearch` は、**ソート済み配列から高速に要素を探す**ための強力なメソッドです。特に大量のデータを扱う場合にパフォーマンスの恩恵が大きくなります。ただし、配列がソート済みでなければならないという前提条件を忘れないようにしましょう。
