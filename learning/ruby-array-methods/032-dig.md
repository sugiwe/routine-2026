# Array#dig

- 日付: 2026-02-01
- URL: https://docs.ruby-lang.org/en/4.0/Array.html#method-i-dig
- daily 記録: [daily/2026-02-01.md](../../daily/2026-02-01.md)

## 基本情報

```ruby
dig(index, *identifiers) → object
```

ネストされたオブジェクト（配列やハッシュ）の中から、指定されたインデックスと識別子で示される要素を検索して返します。途中で `nil` が見つかった場合は `nil` を返します。

## ユーザーの学習記録（daily より）

### 第一印象のメモ

`dig(index, *identifiers) → object`

### コード例

```ruby
# Finds and returns the object in nested object specified by index and identifiers; the nested objects may be instances of various classes. See Dig Methods.
# 指定されたインデックスと識別子でネストされたオブジェクト内のオブジェクトを検索して返します。ネストされたオブジェクトは様々なクラスのインスタンスである可能性があります。Digメソッドを参照してください。
a = [:foo, [:bar, :baz, [:bat, :bam]]]
a.dig(1) # => [:bar, :baz, [:bat, :bam]]
a.dig(1, 2) # => [:bat, :bam]
a.dig(1, 2, 0) # => :bat
a.dig(1, 2, 3) # => nil

# 以下の2つは同じ
item[:batters][:batter][1][:type] # => "Chocolate"
item.dig(:batters, :batter, 1, :type) # => "Chocolate"
```

## 深掘り・補足

### 重要なポイント

**1. 安全なネストアクセス**

`dig` メソッドの最大の利点は、ネストされたデータ構造に安全にアクセスできることです。通常の `[]` を使ったアクセスでは、途中で `nil` に遭遇すると `NoMethodError` が発生しますが、`dig` は `nil` を返すだけです。

```ruby
# 通常のアクセス（危険）
data = {users: [{name: "Alice"}]}
data[:users][0][:email] # => nil
data[:users][1][:name]  # => NoMethodError: undefined method `[]' for nil:NilClass

# dig を使ったアクセス（安全）
data.dig(:users, 0, :email) # => nil
data.dig(:users, 1, :name)  # => nil（エラーにならない）
```

**2. 配列とハッシュの混在に対応**

`dig` は配列とハッシュが混在したネストされたデータ構造でも使えます。

```ruby
data = [
  {name: "Alice", scores: [85, 90, 95]},
  {name: "Bob", scores: [70, 75, 80]}
]

data.dig(0, :scores, 2) # => 95
data.dig(1, :name)      # => "Bob"
data.dig(2, :name)      # => nil（存在しないインデックス）
```

### ユースケース

**1. API レスポンスの安全な解析**

外部 API から取得した JSON データは、フィールドが欠けている可能性があります。

```ruby
# GitHub API のレスポンス例
response = {
  user: {
    name: "octocat",
    profile: {
      bio: "GitHub mascot"
    }
  }
}

# dig を使えば、存在しないフィールドでもエラーにならない
response.dig(:user, :profile, :bio)     # => "GitHub mascot"
response.dig(:user, :profile, :website) # => nil
response.dig(:user, :company, :name)    # => nil
```

**2. 設定ファイルの読み込み**

YAML や JSON で定義された設定ファイルから値を安全に取得できます。

```ruby
config = {
  database: {
    host: "localhost",
    port: 5432
  }
}

config.dig(:database, :host)     # => "localhost"
config.dig(:database, :username) # => nil（デフォルト値を使う）
config.dig(:cache, :redis, :url) # => nil
```

### 注意点

**1. nil と存在しないキーの区別ができない**

`dig` は、キーが存在しないケースと値が `nil` のケースを区別できません。

```ruby
data = {a: nil, b: {c: 1}}

data.dig(:a)    # => nil（値が nil）
data.dig(:x)    # => nil（キーが存在しない）
data.dig(:b, :y) # => nil（ネストしたキーが存在しない）
```

区別が必要な場合は `key?` や `has_key?` を併用します。

```ruby
data.key?(:a) # => true（キーは存在する）
data.key?(:x) # => false（キーが存在しない）
```

**2. パフォーマンスの考慮**

`dig` は内部で複数回のメソッド呼び出しを行うため、頻繁にアクセスする場合は通常の `[]` よりわずかに遅くなります。ただし、可読性と安全性のメリットの方が大きいことがほとんどです。

### 関連メソッドとの比較

**Array#[] との比較**

```ruby
arr = [[1, 2], [3, 4]]

# [] を使った場合
arr[0][1]    # => 2
arr[2][0]    # => NoMethodError（arr[2] が nil のため）

# dig を使った場合
arr.dig(0, 1) # => 2
arr.dig(2, 0) # => nil（安全）
```

**Array#fetch との比較**

```ruby
arr = [[1, 2], [3, 4]]

# fetch はデフォルト値を指定できる
arr.fetch(0, []).fetch(1, 0) # => 2
arr.fetch(2, []).fetch(0, 0) # => 0（デフォルト値）

# dig は nil を返すだけ
arr.dig(2, 0) # => nil
```

**Hash#dig との比較**

配列の `dig` とハッシュの `dig` は同じインターフェースで、混在したデータ構造でも使えます。

```ruby
mixed = {users: [{name: "Alice", tags: ["ruby", "rails"]}]}

mixed.dig(:users, 0, :tags, 1) # => "rails"
```

### 実践的な例

**複雑な JSON データの解析**

```ruby
json_data = {
  weather: {
    location: "Tokyo",
    forecast: [
      {date: "2026-02-01", temp: {high: 15, low: 5}},
      {date: "2026-02-02", temp: {high: 16, low: 6}}
    ]
  }
}

# 2日目の最高気温を取得
json_data.dig(:weather, :forecast, 1, :temp, :high) # => 16

# 存在しないデータは nil
json_data.dig(:weather, :forecast, 5, :temp, :high) # => nil
```

**デフォルト値と組み合わせて使う**

```ruby
# || を使ったデフォルト値
temp = json_data.dig(:weather, :forecast, 5, :temp, :high) || 10
# => 10

# &. (safe navigation operator) との組み合わせ
user = data.dig(:users, 0)
email = user&.dig(:contact, :email) || "not provided"
```
