# Array#map

- 日付: 2026-03-01
- URL: https://docs.ruby-lang.org/en/4.0/Array.html#method-i-map
- daily 記録: [daily/2026-03-01.md](../../daily/2026-03-01.md)

## 基本情報

```ruby
map { |element| ... } → new_array
map → new_enumerator
```

`Array#map` は、配列の各要素に対してブロックを実行し、その戻り値から新しい配列を生成するメソッドです。

**エイリアス**: `collect`

## ユーザーの学習記録（daily より）

### コード例

```ruby
# With a block given, calls the block with each element of self; returns a new array whose elements are the return values from the block:
# ブロックが与えられた場合、selfの各要素でそのブロックを呼び出します。ブロックからの戻り値を要素とする新しい配列を返します：
a = [:foo, 'bar', 2]
a1 = a.map {|element| element.class }
a1 # => [Symbol, String, Integer]

# With no block given, returns a new Enumerator.

# Also aliased as: collect
```

## 深掘り・補足

### 重要なポイント

1. **元の配列は変更されない**
   - `map` は新しい配列を返す（非破壊的メソッド）
   - 元の配列を変更したい場合は `map!` を使用

2. **ブロックの戻り値が新しい要素になる**
   - ブロック内の最後の式の評価結果が、新しい配列の要素となる
   - 各要素を何らかの方法で変換するのが典型的な用途

3. **ブロックなしの場合は Enumerator を返す**
   - 後からブロックを渡すことができる
   - メソッドチェーンで使いやすい

### ユースケース

```ruby
# 数値の配列を2倍にする
numbers = [1, 2, 3, 4, 5]
doubled = numbers.map { |n| n * 2 }
# => [2, 4, 6, 8, 10]

# 文字列の配列を大文字に変換
names = ['alice', 'bob', 'charlie']
upper_names = names.map { |name| name.upcase }
# => ['ALICE', 'BOB', 'CHARLIE']

# オブジェクトから特定の属性を抽出
users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 35 }
]
ages = users.map { |user| user[:age] }
# => [25, 30, 35]

# シンボル to_proc を使った簡潔な書き方
strings = ['1', '2', '3']
integers = strings.map(&:to_i)
# => [1, 2, 3]
```

### map と map! の違い

```ruby
arr = [1, 2, 3, 4, 5]

# map: 元の配列は変更されない
new_arr = arr.map { |a| a * 2 }
# arr => [1, 2, 3, 4, 5] (変更なし)
# new_arr => [2, 4, 6, 8, 10]

# map!: 元の配列が変更される（破壊的メソッド）
arr.map! { |a| a ** 2 }
# arr => [1, 4, 9, 16, 25] (変更された)
```

### Enumerator として使う

```ruby
arr = [1, 2, 3, 4, 5]

# ブロックなしで Enumerator を取得
enum = arr.map
# => #<Enumerator: ...>

# 後からブロックを渡す
result = enum.map { |a| a * 3 }
# => [3, 6, 9, 12, 15]

# with_index と組み合わせる
arr.map.with_index { |val, idx| "#{idx}: #{val}" }
# => ["0: 1", "1: 2", "2: 3", "3: 4", "4: 5"]
```

### パフォーマンスの考慮事項

- `map` は新しい配列を生成するため、メモリを消費します
- 大きな配列で結果を配列として保持する必要がない場合は、`each` の方が効率的な場合があります
- 変換結果をすぐに使わない場合は、遅延評価できる `lazy.map` も検討してください

### 関連メソッド

- **`map!`**: 破壊的バージョン（元の配列を変更）
- **`collect` / `collect!`**: `map` / `map!` のエイリアス
- **`select`**: 条件に合う要素だけを抽出（フィルタリング）
- **`reject`**: 条件に合わない要素を抽出
- **`each`**: 各要素に対して処理を実行（戻り値は元の配列）
- **`flat_map`**: map の後に flatten を実行

### まとめ

`Array#map` は Ruby で最もよく使われるメソッドの一つで、配列の各要素を変換して新しい配列を作る際に使います。関数型プログラミングの「写像（mapping）」の概念を体現しており、データ変換処理を簡潔かつ読みやすく書くことができます。
